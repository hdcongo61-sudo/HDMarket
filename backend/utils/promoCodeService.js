import mongoose from 'mongoose';
import PromoCode from '../models/promoCodeModel.js';
import PromoCodeUsage from '../models/promoCodeUsageModel.js';
import {
  calculateCommissionBreakdown,
  normalizePromoCode,
  serializePromoCodeSummary,
  validatePromoCodeRecord
} from './promoCodeUtils.js';

const promoProjection =
  'code discountType discountValue usageLimit usedCount usedBy startDate endDate isActive referralTag isFlashPromo flashDurationHours autoGenerated';

const toObjectId = (value) => {
  if (!value) return null;
  if (value instanceof mongoose.Types.ObjectId) return value;
  if (!mongoose.Types.ObjectId.isValid(value)) return null;
  return new mongoose.Types.ObjectId(value);
};

const buildPromoError = (message, status = 400, reason = 'promo_invalid') => {
  const error = new Error(message);
  error.status = status;
  error.code = reason;
  return error;
};

export const findPromoCodeByCode = async (code, options = {}) => {
  const normalized = normalizePromoCode(code);
  if (!normalized) return null;

  let query = PromoCode.findOne({ code: normalized }).select(options.select || promoProjection);
  if (options.lean) {
    query = query.lean();
  }
  return query;
};

export const previewPromoForSeller = async ({ code, sellerId, productPrice, now = new Date() }) => {
  const baseCommission = calculateCommissionBreakdown({ productPrice });
  const normalized = normalizePromoCode(code);
  if (!normalized) {
    return {
      valid: false,
      reason: 'missing_code',
      message: 'Veuillez saisir un code promo.',
      promo: null,
      commission: baseCommission
    };
  }

  const promo = await findPromoCodeByCode(normalized, { lean: true });
  const validation = validatePromoCodeRecord({ promo, sellerId, at: now });

  if (!validation.valid) {
    return {
      valid: false,
      reason: validation.reason,
      message: validation.message,
      promo: promo ? serializePromoCodeSummary(promo) : null,
      commission: baseCommission
    };
  }

  const commission = calculateCommissionBreakdown({ productPrice, promo });

  return {
    valid: true,
    reason: 'ok',
    message:
      commission.isWaived
        ? 'Commission annulée grâce au code promo.'
        : `Code valide: ${commission.discountRate}% de réduction sur la commission.`,
    promo: serializePromoCodeSummary(promo),
    commission
  };
};

export const consumePromoCodeForSeller = async ({
  code,
  sellerId,
  product,
  paymentId = null,
  ipAddress = null,
  userAgent = null,
  session = null
}) => {
  const productPrice = Number(product?.price || 0);
  const baseCommission = calculateCommissionBreakdown({ productPrice });
  const normalized = normalizePromoCode(code);

  if (!normalized) {
    return {
      applied: false,
      promo: null,
      commission: baseCommission
    };
  }

  const sellerObjectId = toObjectId(sellerId);
  if (!sellerObjectId) {
    throw buildPromoError('Utilisateur vendeur invalide pour le code promo.', 400, 'invalid_seller');
  }

  const now = new Date();

  const promo = await PromoCode.findOneAndUpdate(
    {
      code: normalized,
      isActive: true,
      startDate: { $lte: now },
      endDate: { $gte: now },
      usedBy: { $ne: sellerObjectId },
      $expr: { $lt: ['$usedCount', '$usageLimit'] }
    },
    {
      $inc: { usedCount: 1 },
      $addToSet: { usedBy: sellerObjectId }
    },
    {
      new: true,
      session
    }
  );

  if (!promo) {
    const preview = await previewPromoForSeller({
      code: normalized,
      sellerId: sellerObjectId,
      productPrice,
      now
    });
    throw buildPromoError(preview.message || 'Code invalide ou expiré.', 400, preview.reason || 'promo_invalid');
  }

  const commission = calculateCommissionBreakdown({ productPrice, promo });

  try {
    await PromoCodeUsage.create(
      [
        {
          promoCode: promo._id,
          codeSnapshot: promo.code,
          seller: sellerObjectId,
          product: product._id,
          payment: paymentId,
          discountType: promo.discountType,
          discountValue: Number(promo.discountValue || 0),
          baseCommissionAmount: commission.baseAmount,
          discountAmount: commission.discountAmount,
          commissionDueAmount: commission.dueAmount,
          referralTag: promo.referralTag || '',
          ipAddress,
          userAgent
        }
      ],
      { session }
    );
  } catch (error) {
    if (error?.code === 11000) {
      throw buildPromoError('Vous avez déjà utilisé ce code promo.', 400, 'already_used');
    }
    throw error;
  }

  const updates = {
    $inc: {
      totalCommissionWaived: Number(commission.discountAmount || 0)
    }
  };

  if (Number(promo.usedCount || 0) >= Number(promo.usageLimit || 0) && promo.isActive) {
    updates.$set = {
      isActive: false,
      deactivatedAt: now,
      deactivatedReason: 'usage_limit_reached'
    };
  }

  await PromoCode.updateOne({ _id: promo._id }, updates, { session });

  return {
    applied: true,
    promo,
    commission
  };
};
